\documentclass{article}
\usepackage{natbib}
\usepackage{graphicx}
\include{preamble.tex}

\title{Wavelets for Bacterial Clustering and Regime Detection}
\author{Kris Sankaran}

\begin{document}
\maketitle

These notes summarize some thoughts on applying wavelet methods to the
time series data in the microbiome. The results we have obtained so far have
been somewhat disappointing, but it's at least worth documenting the overall
process, along with some of the basic commands you can use to apply wavelets in
R.

\section{Wavelets review and practical tips}

From a statistical perspective, wavelets can be used to automatically featurize
complex structure in time series. More formally, a family of wavelets are an
orthonormal basis for functions, analogous to the Fourier basis (indeed,
periodicgrams are often used to featurize frequency features in time series).
Two important differences are that (1) wavelets are localized, meaning they can
represent some pattern that appears within a particular time interval and (2)
many functions have sparse representations in the wavelet basis, even if they
are not smooth -- in this sense sparsity is a more natural statistical
assumption than smoothness \cite{johnstone2011gaussian}.

We'll be using a Haar basis throughout, since they're easiest to interpret. Two
example basis functions are available in figures \ref{fig:wavelet-1} and
\ref{fig:wavelet-2}. Note that they are both localized around specific time
windows. Also, they have different scales -- the first is more likely to ``pick
up'' jumps in the time series around its small window. Since there are wavelet
basis functions with many different centers and scales, and since they are
sometimes redundant, the basis is called overcomplete. One goal of wavelet
analysis is identify a sparse subset of basis elements that can well-approximate
the original function. While this is often used for denoising, we will try to
use the resulting basis elements for scientific understanding.

The wavelet transform of $y$ provides the coefficients of $y$ with respect to
the wavelet basis. For a discrete wavelet transform (i.e., $y \in \reals^{n}$),
this means $y = AW$ for a wide (overcomplete) wavelet basis matrix $W$ and
coefficients $A$. While this description is useful for understanding wavelets
from a statistical point of view, this description is usually avoided, because
the pyramid algorithm provides an efficient dynamic programming-ish approach to
calculating the transform coefficients without ever constructing the (large)
matrix containing all the wavelet basis elements.

More concretely, what is the wavelet transfom of a sequence $y_{1}, \dots,
y_{n}$? We construct two sets of coefficients, called the mother and father
wavelet coefficients. These are particularly simple to describe in the Haar
wavelet case; we follow the exposition of \citep{nason2011wavelet}. The first
set (those at finest scale) of mother coefficients are the differences between
neighboring points $y_{2k +1} - y_{2k}$ for all $k$. Note that this is not just
the differenced sequence -- we are only taking the difference between even / odd
pairs, not all pairs. Intuitively, it makes sense that these can be a useful
feature for describing the structure of my time series. The associated father
wavelets at this level are defined as the parallel pairwise sums $y_{2k + 1} +
y_{2k}$. Note that the original sequence can be constructed from these two
statistics -- this forms the basic idea of the inverse wavelet transform. At the
next scale (coarser level), instead of considering adjacent pairs, the two
halves of sequences of length 4 are compared. Generally, at the $l^{th}$ level,
we consider the difference (and sum) in averages between adjacent sequences of
length $2^{l - 1}$. The fact that these statistics can be computed from the
statistics at the previous level is the basic insight needed to derive the
pyramid algorithm.

\subsection{Implementation}

There are a few R packages for working with wavelets in R, including
\texttt{wmtsa}, \texttt{wavethresh}, and \texttt{wavelets}. I have found the
\texttt{wavethresh} package easiest to work with, partly because it is applied
in \citep{nason2011wavelet} and also because it doesn't have so many features
that it becomes confusing. The main functions in this package to know about are,

\begin{enumerate}
  \item \texttt{wd} This computes the discrete wavelet transform of a sequence.
    You can specify different wavelet basis here. The result is an object of class
    \textt{wd.object}, which has a nice \texttt{plot} method showing the
    coefficients at different centers and scales.
  \item \texttt{wr} Given a wavelet transform object, this recovers the original
    sequence. It can be especially useful to use this after applying \texttt{threshold}.
  \item \texttt{accessC} This gives the father wavelet coefficients across levels.
  \item \texttt{accessD} This gives the mother wavelet coefficients across levels.
  \item \texttt{putC} You can manually change the father wavelet coefficients
    with this. Note that the smallest level is 0 and the largest is 1 more than
    the number in of mother wavelet levels.
  \item \texttt{putD} This does the same for mother wavelet coefficients.
\end{enumerate}

One annoying thing about the \texttt{wavethresh} package is that \texttt{wd}
fails on sequences whose lengths are not multiples of 2. There are two typical ways around this,

\begin{enumerate}
\item Zero-padding: Add extra zeros to the end of your sequence until the length is a multiple of 2.
\item Interpolation: Use \texttt{approxfun} to interpolate original sequence
  onto a grid whose length is a multiple of 2. This is the approach used in this
  note. While it is nice for working with sequences that aren't sampled evenly
  over time, this does complicate bookeeping with joining to sample-specific
  data down the road. It's doable though -- you just need to build a map between
  the original and interpolated time points, assigning interpolated times to
  their nearest observed time.
\end{enumerate}

\section{Clustering denoised series}

\section{Clustering wavelet coefficients}

\section{Regime detection?}

\begin{figure}[ht]
  \centering
  \includegraphics[width=\textwidth]{figure/concat_wavelet_hclust_reconstruction}
  \caption{\label{fig:label} }
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[width=\textwidth]{figure/concat_wavelet_hclust_averages}
  \caption{\label{fig:label} }
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[width=\textwidth]{figure/stacked_wavelet_hclust}
  \caption{\label{fig:label} }
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[width=\textwidth]{figure/wavelet_centroids-sd}
  \caption{\label{fig:label} }
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[width=\textwidth]{figure/wavelet_centroids-n}
  \caption{\label{fig:label} }
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[width=\textwidth]{figure/wavelet_time_cluster-1}
  \caption{\label{fig:label} }
\end{figure}

\bibliographystyle{plainnat}
\bibliography{wavelet.bib}


\end{document}
